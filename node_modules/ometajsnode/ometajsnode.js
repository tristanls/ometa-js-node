exports.version = "0.2.0";

//capture module context
var module = this;

var fs = require( 'fs' ),
    logly = require( 'logly' ),
    ometa = require( './ometajs/ometajs.js' );

var mode,
    loglyMode,
    grammarFileName,
    inputFileNames,
    compilerFileName,
    interpreterFileName,
    outputFileName,
    rootParserExpression,
    rootInterpreterExpression,
    rootCompilerExpression,
    utilities;

var execute = function( mode, loglyMode, grammarFileName, inputFileNames, 
    compilerFileName, interpreterFileName, outputFileName, rootParserExpression,
    rootInterpreterExpression, rootCompilerExpression, utilities ) {
  module.mode = mode;
  module.loglyMode = loglyMode;
  module.grammarFileName = grammarFileName;
  module.inputFileNames = inputFileNames;
  module.compilerFileName = compilerFileName;
  module.interpreterFileName = interpreterFileName;
  module.outputFileName = outputFileName;
  module.rootParserExpression = rootParserExpression;
  module.rootInterpreterExpression = rootInterpreterExpression;
  module.rootCompilerExpression = rootCompilerExpression;
  module.utilities = utilities;
  
  logly.mode( loglyMode );
  
  logly.verbose( 'starting execution in ' + mode + ' mode...' );
  
  __Utilities = {};
  if ( utilities ) {
    logly.verbose( 'loading utilities...' );
    
    for ( var i = 0; i < utilities.length; i++ ) {
      var temp = null;
      try {
        temp = require( utilities[ i ] );
      } catch ( err ) {
        logly.error( err.message );
        process.exit( 1 );
      }
      if ( temp ) {
        if ( !temp.utilityName ) {
          logly.error( "module '" + utilities[ i ] + "' does not export 'utilityName', aborting..." );
          process.exit( 1 );
        }
        __Utilities[ temp.utilityName ] = temp;
        logly.debug( "loaded utility '" + utilities[ i ] + "' as __Utilities[ '" + temp.utilityName + "' ]" );
      }
    }
    logly.verbose( "utilities loaded" );
  } else {
    logly.verbose( "no utilities to load" );
  }
  
  // read grammar string from file
  logly.verbose( "reading grammar file..." );
  fs.readFile( grammarFileName, 'utf8', grammarFileReadComplete);

};

var grammarFileReadComplete = function( err, grammarString ) {
  if ( err ) {
    logly.error( err.message );
    process.exit( 1 );
  };
  
  logly.verbose( "completed reading grammar file " );
  logly.debug( 'grammar file:\n' + grammarString );
  
  logly.verbose( "building parser..." );
  
  var tree = ometa.BSOMetaJSParser.matchAll(
      grammarString,
      "topLevel",
      undefined,
      function( m, i ) {
        throw objectThatDelegatesTo( fail, { errorPos: i } );
      });
  
  var parserString = ometa.BSOMetaJSTranslator.match(
      tree,
      "trans",
      undefined,
      translationError );
  
  logly.verbose( "parser build complete" );
  
  if ( module.mode == 'parse' ) {
    
    parse( parserString, module.outputFileName, module.inputFileNames, 
        module.rootParserExpression );
    
  } else if ( module.mode == 'interpret' ) {
    
    startInterpreting( parserString, module.outputFileName, 
        module.interpreterFileName, module.inputFileNames, 
        module.rootParserExpression, module.rootInterpreterExpression );
    
  } else if ( module.mode == 'compile' ) {
    
    startCompiling( parserString, module.outputFileName,
        module.compilerFileName, module.inputFileNames,
        module.rootParserExpression, module.rootCompilerExpression );
  }
} ;

var startCompiling = function( parserString, outputFileName,
    compilerFileName, inputFileNames, rootParserExpression, 
    rootCompilerExpression ) {
  
  fs.readFile( compilerFileName, 'utf8', function( err, compilerString ) {
    if ( err ) {
      logly.error( err.message );
      process.exit( 1 );
    }
    
    logly.verbose( "completed reading compiler file" );
    logly.debug( "compiler file:\n" + compilerString );
    
    logly.verbose( "building compiler..." );
    
    // FIXME: this looks awfully a lot like interpreting...
    //        i think there is a difference with more complex examples
    //        and optimizations, but keep a lookout for refactoring 
    //        opportunities
    
    var compilerTree = ometa.BSOMetaJSParser.matchAll(
        compilerString,
        "topLevel",
        undefined,
        function( m, i ) {
          throw objectThatDelegatesTo( fail, { errorPos: i } );
        });
    
    compilerString = ometa.BSOMetaJSTranslator.match(
        compilerTree,
        "trans",
        undefined,
        translationError );
    

    logly.verbose( "compiler build complete" );
    
    // parse input files and call the callback with parse results
    parse( parserString, undefined, inputFileNames, rootParserExpression,
        function( results ) {
          compile( compilerString, outputFileName, rootCompilerExpression, 
              results );
    });
  });
};

var startInterpreting = function( parserString, outputFileName, 
    interpreterFileName, inputFileNames, rootParserExpression,
    rootInterpreterExpression ) {
    
  var interpreterString = '';
  if ( !interpreterFileName ) {
    // assume that if there is no interpreter specified, that grammar file
    // can interpret on its own!
    logly.verbose( "no interpreter file specified, assuming grammar file can interpret..." );
    interpreterString = parserString;
    interpret( interpreterString, outputFileName, inputFileNames, 
        rootInterpreterExpression );
  } else {
    fs.readFile( interpreterFileName, 'utf8', function( err, interpreterString ) {
      if ( err ) {
        logly.error( err.message );
        process.exit( 1 );
      }
      
      logly.verbose( "completed reading interpreter file " );
      logly.debug ( "interpreter file:\n" + interpreterString );
      
      logly.verbose( "building interpreter..." );
      
      var interpreterTree = ometa.BSOMetaJSParser.matchAll(
          interpreterString,
          "topLevel",
          undefined,
          function( m, i ) {
            throw objectThatDelegatesTo( fail, { errorPos: i } );
          });
      
      interpreterString = ometa.BSOMetaJSTranslator.match(
          interpreterTree,
          "trans",
          undefined,
          translationError );
      

      logly.verbose( "interpreter build complete" );
      
      // parse input files and call the callback with parse results
      parse( parserString, undefined, inputFileNames, rootParserExpression,
          function( results ) {
            interpret( interpreterString, outputFileName, undefined,
                rootInterpreterExpression, results );
      });
    });
  };
};

var compile = function( compilerString, outputFileName, rootCompilerExpression,
    rawInput ) {
  // no matter what the compiler grammar is called, we alias it as __ometajsnode__Compiler
  compilerString = "__ometajsnode__Compiler=" + compilerString;
  eval( compilerString );
  
  logly.debug( 'compiler:\n' + compilerString );
  
  var results = [];

  logly.verbose( "compiling..." );
  for ( var i = 0; i < rawInput.length; i++ ) {
    
    var result = __ometajsnode__Compiler.match( rawInput[ i ],
        rootCompilerExpression );
    
    logly.debug( "compilation result:\n" + result.toString() );
    
    results.push( result );
  }
  logly.verbose( "completed compiling");
  
  handleResultsAfterProcessing( 0, results );
};

var interpret = function( interpreterString, outputFileName, inputFileNames, 
    rootInterpreterExpression, rawInput, handleRaw ) {
  //no matter what the grammar is called, we alias it as __ometajsnode__Interpreter
  interpreterString = "__ometajsnode__Interpreter=" + interpreterString;
  eval( interpreterString );
  
  logly.debug( 'interpreter:\n' + interpreterString );
  
  var results = [];
  
  if ( rawInput ) {
    // this means we are using interpreter on outputs from a parser
    for ( var i = 0; i < rawInput.length; i++ ) {
      logly.verbose( "interpreting..." );
      
      var result = __ometajsnode__Interpreter.match( rawInput[ i ],
          rootInterpreterExpression );
      
      logly.verbose( "completed interpreting" );
      logly.debug( "interpreting result:\n" + result.toString() );
      
      results.push( result );
    }
    handleResultsAfterProcessing( 0, results, handleRaw );
  } else if ( inputFileNames.length > 0 ) {
    // this means we are using parser/interpreter combo working on raw
    //  program strings
    var numberOfFilesBeingProcessed = 0;
    for ( var i = 0; i < inputFileNames.length; i++ ) {
      numberOfFilesBeingProcessed++;
      // use closure to capture current file name
      ( function() {
        var fileName = inputFileNames[ i ];
        fs.readFile( fileName, 'utf8', function( err, programString ) {
          if ( err ) {
            logly.error( err.message );
            process.exit( 1 );
          }
          
          logly.verbose( "completed reading program file '" + fileName + "'" );
          logly.debug( "program file:\n" + programString );
          
          logly.verbose( "interpreting..." );
          
          var result = __ometajsnode__Interpreter.matchAll( programString, 
              rootInterpreterExpression );
          
          logly.verbose( "completed interpreting" );
          logly.debug( "interpreting result:\n" + result.toString() );
          
          results.push( result );
          numberOfFilesBeingProcessed--;
          handleResultsAfterProcessing( numberOfFilesBeingProcessed, results,
              handleRaw );
        });
      })();
    }
  } else {
    logly.error( 'stdin input is not yet supported' );
    process.exit( 1 );
  }
};

var parse = function( parserString, outputFileName, inputFileNames, 
    rootParserExpression, handleRaw ) {
  // no matter what the parser is called, we alias it as __ometajsnode__Parser
  parserString = "__ometajsnode__Parser=" + parserString;
  eval( parserString );
  
  logly.debug( 'parser:\n' + parserString );
  
  var results = [];
  
  if ( inputFileNames.length > 0 ) {
    var numberOfFilesBeingProcessed = 0;
    for ( var i = 0; i < inputFileNames.length; i++ ) {
      numberOfFilesBeingProcessed++;
      // use closure to capture current file name
      ( function() {
        var fileName = inputFileNames[ i ];
        fs.readFile( fileName, 'utf8', function( err, programString ) {
          if ( err ) {
            logly.error( err.message );
            process.exit( 1 );
          }
          
          logly.verbose( "completed reading program file '" + fileName + "'" );
          logly.debug( "program file:\n" + programString );
          
          logly.verbose( "parsing..." );
          
          var result = __ometajsnode__Parser.matchAll( programString, 
              rootParserExpression );
          
          logly.verbose( "completed parsing" );
          logly.debug( "parsing result:\n" + result.toString() );
          
          results.push( result );
          numberOfFilesBeingProcessed--;
          handleResultsAfterProcessing( numberOfFilesBeingProcessed, results, 
              handleRaw );
        });
      })();
    }
  } else {
    logly.error( 'stdin input is not yet supported' );
    process.exit( 1 );
  }
};

var handleResultsAfterProcessing = function( numberOfFilesBeingProcessed, results,
    handleRaw ) {
  if ( numberOfFilesBeingProcessed > 0 ) return; // still processing files
  
  if ( handleRaw ) {
    // this is used for to return partial results to the ometajsnode
    handleRaw( results );
    return;
  }
  
  if ( module.outputFileName ) {
    var fileContents = '';
    for ( var i = 0; i < results.length; i++ ) {
      fileContents += results[ i ].toString() + '\n';
    } 
    fs.writeFile( module.outputFileName, fileContents.toString(), function( err ) {
      if ( err ) {
        logly.error( err.message );
        process.exit( 1 );
      }
      logly.verbose( "wrote to file '" + module.outputFileName + "'" );
    });
  } else {
    // no output file, so write to stdout
    for ( var i = 0; i < results.length; i++ ) {
      process.stdout.write( results[ i ].toString() + '\n' );
    }
  }
};

var translationError = function( m, i ) {
  logly.error( 'Translation error!' );
  throw fail;
};

exports.execute = execute;