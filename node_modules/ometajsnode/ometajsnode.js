exports.version = "1.0.3";

//capture module context
var module = this;

var fs = require( 'fs' ),
    logly = require( 'logly' ),
    ometa = require( './ometajs/ometajs.js' );

var loglyMode,
    grammarFileName,
    inputFileNames,
    outputFileName,
    rootGrammarExpression,
    utilities;

var execute = function( loglyMode, grammarFileName, inputFileNames, 
    outputFileName, rootGrammarExpression, utilities, pipeMode, noPipeOut ) {
  module.loglyMode = loglyMode;
  module.grammarFileName = grammarFileName;
  module.inputFileNames = inputFileNames;
  module.outputFileName = outputFileName;
  module.rootGrammarExpression = rootGrammarExpression;
  module.utilities = utilities;
  module.pipeMode = pipeMode;
  module.noPipeOut = noPipeOut;
  
  logly.mode( loglyMode );
  
  __Utilities = {};
  if ( utilities ) {
    logly.verbose( 'loading utilities...' );
    
    for ( var i = 0; i < utilities.length; i++ ) {
      var temp = null;
      try {
        temp = require( utilities[ i ] );
      } catch ( err ) {
        logly.error( err.message );
        process.exit( 1 );
      }
      if ( temp ) {
        if ( !temp.utilityName ) {
          logly.error( "module '" + utilities[ i ] + "' does not export 'utilityName', aborting..." );
          process.exit( 1 );
        }
        __Utilities[ temp.utilityName ] = temp;
        logly.debug( "loaded utility '" + utilities[ i ] + "' as __Utilities[ '" + temp.utilityName + "' ]" );
      }
    }
    logly.verbose( "utilities loaded" );
  } else {
    logly.verbose( "no utilities to load" );
  }
  
  // read grammar string from file
  logly.verbose( "reading grammar file..." );
  fs.readFile( grammarFileName, 'utf8', grammarFileReadComplete);

};

var grammarFail = { toString: function() {
  var min = 0;
  if ( this.errorPos - 20 > min ) {
    min = this.errorPos;
  }
  var max = this.grammarString.length;
  if ( this.errorPos + 20 < max ) {
    max = this.errorPos + 20;
  }
  // match failed notification
  var message = "match failed at position: " + this.errorPos + '\n';
  // grammar neighborhood where match failed
  message += this.grammarString.substring( min, max ) + '\n';
  // carret specifying location where match failed
  var snippetSize = max - min;
  for ( var i = 0; i < ( snippetSize / 2 ); i++ ){
    message += ' ';
  }
  message += '^';
  for ( var i = ( snippetSize / 2 ); i < snippetSize; i++ ) {
    message += ' ';
  }
  message += '\n';
  return message;
}};

var grammarFileReadComplete = function( err, grammarString ) {
  if ( err ) {
    logly.error( err.message );
    process.exit( 1 );
  };
  
  logly.verbose( "completed reading grammar file " );
  logly.debug( 'grammar file:\n' + grammarString );
  
  logly.verbose( "building grammar parser..." );
  
  var tree = ometa.BSOMetaJSParser.matchAll(
      grammarString,
      "topLevel",
      undefined,
      function( m, i ) {
        throw objectThatDelegatesTo( grammarFail, { 
          errorPos: i,
          grammarString: grammarString } );
      });
  
  var parserString = ometa.BSOMetaJSTranslator.match(
      tree,
      "trans",
      undefined,
      translationError );
  
  logly.verbose( "grammar parser build complete" );
  
  parse( parserString, module.outputFileName, module.inputFileNames, 
      module.rootGrammarExpression );
    
} ;

var parse = function( parserString, outputFileName, inputFileNames, 
    rootGrammarExpression ) {
  // no matter what the parser is called, we alias it as __ometajsnode__Parser
  parserString = "__ometajsnode__Parser=" + parserString;
  eval( parserString );
  
  logly.debug( 'parser:\n' + parserString );
  
  var results = [];
  
  if ( typeof( inputFileNames ) === "string" ) {
    // input is from stdin
    var result = null;
    if ( module.pipeMode ) {
      // we are getting JSON encoded parse object, likely a result from
      //   another ometajsnode parse up the pipe chain
      var program = JSON.parse( inputFileNames );
      logly.verbose( "reading pipe program from stdin" );
      logly.debug( "program:\n" + program );
      
      logly.verbose( "parsing..." );
      
      result = __ometajsnode__Parser.match( program,
          rootGrammarExpression );
    } else {
      var programString = inputFileNames;
      logly.verbose( "reading program from stdin" );
      logly.debug( "program:\n" + programString );
      
      logly.verbose( "parsing..." );
      
      result = __ometajsnode__Parser.matchAll( programString, rootGrammarExpression );
    }
    
    logly.verbose( "completed parsing" );
    //logly.debug( 'extended parsing result:\n' + Object.prototype.toString.call( this, result ) );
    logly.debug( "parsing result:\n" + result.toString() );
    
    handleResultsAfterProcessing( [ result ] );
    
  } else if ( inputFileNames.length > 0 ) {
    // input is from an array of program file names
    var numberOfFilesBeingProcessed = 0;
    for ( var i = 0; i < inputFileNames.length; i++ ) {
      numberOfFilesBeingProcessed++;
      // use closure to capture current file name
      ( function() {
        var fileName = inputFileNames[ i ];
        fs.readFile( fileName, 'utf8', function( err, programString ) {
          if ( err ) {
            logly.error( err.message );
            process.exit( 1 );
          }
          
          logly.verbose( "completed reading file '" + fileName + "'" );
          logly.debug( "file:\n" + programString );
          
          logly.verbose( "parsing..." );
          
          var result = null;
          if ( module.pipeMode ) {
            // we are getting JSON encoded parse object
            var program = JSON.parse( programString );
            logly.log( program );
            
            result = __ometajsnode__Parser.match( program,
                rootGrammarExpression );
            
          } else {
            
            result = __ometajsnode__Parser.matchAll( programString, 
                rootGrammarExpression );
            
          }
          
          logly.verbose( "completed parsing" );
          logly.debug( "parsing result:\n" + result.toString() );
          
          results.push( result );
          numberOfFilesBeingProcessed--;
          if ( numberOfFilesBeingProcessed <= 0 ) {
            handleResultsAfterProcessing( results );
          }
        });
      })();
    }
  } else {
    logly.error( 'input ' + inputFileNames.toString() + ' not recognized' );
    process.exit( 1 );
  }
};

var handleResultsAfterProcessing = function( results, handleRaw ) {
  
  if ( handleRaw ) {
    // this is used for to return partial results to the ometajsnode
    handleRaw( results );
    return;
  }
  
  if ( module.outputFileName ) {
    var fileContents = '';
    for ( var i = 0; i < results.length; i++ ) {
      if ( module.noPipeOut ) {
        fileContents += results[ i ];
      } else {
        fileContents += JSON.stringify( results[ i ] );
      }
    } 
    fs.writeFile( module.outputFileName, fileContents, function( err ) {
      if ( err ) {
        logly.error( err.message );
        process.exit( 1 );
      }
      logly.verbose( "wrote to file '" + module.outputFileName + "'" );
    });
  } else {
    // no output file, so write to stdout
    for ( var i = 0; i < results.length; i++ ) {
      if ( module.noPipeOut ) {
        process.stdout.write( results[ i ].toString() + '\n' );
      } else {
        process.stdout.write( JSON.stringify( results[ i ] ) );
      }
    }
  }
};

var translationError = function( m, i ) {
  logly.error( 'Translation error!' );
  throw fail;
};

exports.execute = execute;