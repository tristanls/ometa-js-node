exports.version = "0.1.0";

//capture module context
var module = this;

var fs = require( 'fs' ),
    logly = require( 'logly' ),
    ometa = require( './ometajs/ometajs.js' );

var mode,
    loglyMode,
    grammarFileName,
    inputFileNames,
    compilerFileName,
    interpreterFileName,
    outputFileName,
    rootParserExpression,
    rootInterpreterExpression,
    rootCompilerExpression;

var execute = function( mode, loglyMode, grammarFileName, inputFileNames, 
    compilerFileName, interpreterFileName, outputFileName, rootParserExpression,
    rootInterpreterExpression, rootCompilerExpression) {
  module.mode = mode;
  module.loglyMode = loglyMode;
  module.grammarFileName = grammarFileName;
  module.inputFileNames = inputFileNames;
  module.compilerFileName = compilerFileName;
  module.interpreterFileName = interpreterFileName;
  module.outputFileName = outputFileName;
  module.rootParserExpression = rootParserExpression;
  module.rootInterpreterExpression = rootInterpreterExpression;
  module.rootCompilerExpression = rootCompilerExpression;
  
  logly.mode( loglyMode );
  
  logly.verbose( 'starting execution in ' + mode + ' mode...' );
  
  // read grammar string from file
  logly.verbose( "reading grammar file..." );
  fs.readFile( grammarFileName, 'utf8', grammarFileReadComplete);

};

var grammarFileReadComplete = function( err, grammarString ) {
  if ( err ) {
    logly.error( err.message );
    process.exit( 1 );
  };
  
  logly.verbose( "completed reading grammar file " );
  logly.debug( 'grammar file:\n' + grammarString );
  
  logly.verbose( "building parser..." );
  
  var tree = ometa.BSOMetaJSParser.matchAll(
      grammarString,
      "topLevel",
      undefined,
      function( m, i ) {
        throw objectThatDelegatesTo( fail, { errorPos: i } );
      });
  
  var parserString = ometa.BSOMetaJSTranslator.match(
      tree,
      "trans",
      undefined,
      translationError );
  
  logly.verbose( "parser build complete" );
  
  if ( module.mode == 'parse' ) {
    
    parse( parserString, module.outputFileName, module.inputFileNames, 
        module.rootParserExpression );
    
  } else if ( module.mode == 'interpret' ) {
    
    startInterpreting( parserString, module.outputFileName, 
        module.interpreterFileName, module.inputFileNames, 
        module.rootParserExpression, module.rootInterpreterExpression );
    
  } else if ( module.mode == 'compile' ) {
    logly.error( 'compile mode not yet implemented' );
    process.exit( 1 );
  }
} ;

var startInterpreting = function( parserString, outputFileName, 
    interpreterFileName, inputFileNames, rootParserExpression,
    rootInterpreterExpression ) {
    
  var interpreterString = '';
  if ( !interpreterFileName ) {
    // assume that if there is no interpreter specified, that grammar file
    // can interpret on its own!
    logly.verbose( "no interpreter file specified, assuming grammar file can interpret..." );
    interpreterString = parserString;
    interpret( interpreterString, outputFileName, inputFileNames, 
        rootInterpreterExpression );
  } else {
    fs.readFile( interpreterFileName, 'utf8', function( err, interpreterString ) {
      if ( err ) {
        logly.error( err.message );
        process.exit( 1 );
      }
      
      logly.verbose( "completed reading interpreter file " );
      logly.debug ( "interpreter file:\n" + interpreterString );
      
      logly.verbose( "building interpreter..." );
      
      var interpreterTree = ometa.BSOMetaJSParser.matchAll(
          interpreterString,
          "topLevel",
          undefined,
          function( m, i ) {
            throw objectThatDelegatesTo( fail, { errorPos: i } );
          });
      
      interpreterString = ometa.BSOMetaJSTranslator.match(
          interpreterTree,
          "trans",
          undefined,
          translationError );
      

      logly.verbose( "interpreter build complete" );
      
      // parse input files and call the callback with parse results
      parse( parserString, undefined, inputFileNames, rootParserExpression,
          function( results ) {
            interpret( interpreterString, outputFileName, undefined,
                rootInterpreterExpression, results );
      });
    });
  }
};

var interpret = function( interpreterString, outputFileName, inputFileNames, 
    rootInterpreterExpression, rawInput, handleRaw ) {
  //no matter what the grammar is called, we alias it as __ometajsnode__Interpreter
  interpreterString = "__ometajsnode__Interpreter=" + interpreterString;
  eval( interpreterString );
  
  logly.debug( 'interpreter:\n' + interpreterString );
  
  var results = [];
  
  if ( rawInput ) {
    // this means we are using interpreter on outputs from a parser
    for ( var i = 0; i < rawInput.length; i++ ) {
      logly.verbose( "interpreting..." );
      
      var result = __ometajsnode__Interpreter.match( rawInput[ i ],
          rootInterpreterExpression );
      
      logly.verbose( "completed interpreting" );
      logly.debug( "interpreting result:\n" + result.toString() );
      
      results.push( result );
    }
    handleResultsAfterProcessing( 0, results, handleRaw );
  } else if ( inputFileNames.length > 0 ) {
    // this means we are using parser/interpreter combo working on raw
    //  program strings
    var numberOfFilesBeingProcessed = 0;
    for ( var i = 0; i < inputFileNames.length; i++ ) {
      numberOfFilesBeingProcessed++;
      // use closure to capture current file name
      ( function() {
        var fileName = inputFileNames[ i ];
        fs.readFile( fileName, 'utf8', function( err, programString ) {
          if ( err ) {
            logly.error( err.message );
            process.exit( 1 );
          }
          
          logly.verbose( "completed reading program file '" + fileName + "'" );
          logly.debug( "program file:\n" + programString );
          
          logly.verbose( "interpreting..." );
          
          var result = __ometajsnode__Interpreter.matchAll( programString, 
              rootInterpreterExpression );
          
          logly.verbose( "completed interpreting" );
          logly.debug( "interpreting result:\n" + result.toString() );
          
          results.push( result );
          numberOfFilesBeingProcessed--;
          handleResultsAfterProcessing( numberOfFilesBeingProcessed, results,
              handleRaw );
        });
      })();
    }
  } else {
    logly.error( 'stdin input is not yet supported' );
    process.exit( 1 );
  }
};

var parse = function( parserString, outputFileName, inputFileNames, 
    rootParserExpression, handleRaw ) {
  // no matter what the parser is called, we alias it as __ometajsnode__Parser
  parserString = "__ometajsnode__Parser=" + parserString;
  eval( parserString );
  
  logly.debug( 'parser:\n' + parserString );
  
  var results = [];
  
  if ( inputFileNames.length > 0 ) {
    var numberOfFilesBeingProcessed = 0;
    for ( var i = 0; i < inputFileNames.length; i++ ) {
      numberOfFilesBeingProcessed++;
      // use closure to capture current file name
      ( function() {
        var fileName = inputFileNames[ i ];
        fs.readFile( fileName, 'utf8', function( err, programString ) {
          if ( err ) {
            logly.error( err.message );
            process.exit( 1 );
          }
          
          logly.verbose( "completed reading program file '" + fileName + "'" );
          logly.debug( "program file:\n" + programString );
          
          logly.verbose( "parsing..." );
          
          var result = __ometajsnode__Parser.matchAll( programString, 
              rootParserExpression );
          
          logly.verbose( "completed parsing" );
          logly.debug( "parsing result:\n" + result.toString() );
          
          results.push( result );
          numberOfFilesBeingProcessed--;
          handleResultsAfterProcessing( numberOfFilesBeingProcessed, results, 
              handleRaw );
        });
      })();
    }
  } else {
    logly.error( 'stdin input is not yet supported' );
    process.exit( 1 );
  }
};

var handleResultsAfterProcessing = function( numberOfFilesBeingProcessed, results,
    handleRaw ) {
  if ( numberOfFilesBeingProcessed > 0 ) return; // still processing files
  
  if ( handleRaw ) {
    // this is used for to return partial results to the ometajsnode
    handleRaw( results );
    return;
  }
  
  if ( module.outputFileName ) {
    var fileContents = '';
    for ( var i = 0; i < results.length; i++ ) {
      fileContents += results[ i ].toString() + '\n';
    } 
    fs.writeFile( module.outputFileName, fileContents.toString(), function( err ) {
      if ( err ) {
        logly.error( err.message );
        process.exit( 1 );
      }
      logly.verbose( "wrote to file '" + module.outputFileName + "'" );
    });
  } else {
    // no output file, so write to stdout
    for ( var i = 0; i < results.length; i++ ) {
      process.stdout.write( results[ i ].toString() );
    }
  }
};

var translationError = function( m, i ) {
  logly.error( 'Translation error!' );
  throw fail;
};

exports.execute = execute;